---
title: "interpolacion ejercicio 6"
author: "Monserrath Antonio Cordero"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Ejercicio 7

# FUNCIONES AUXILIARES

# Tabla de diferencias hacia adelante
```{r}
forward_diff_table <- function(x, y) {
  n <- length(y)
  diffs <- list(y)
  for (k in 1:(n - 1)) {
    diffs[[k + 1]] <- diff(diffs[[k]])
  }
  df <- data.frame(x = x)
  for (k in 1:length(diffs)) {
    col <- c(rep(NA, k - 1), diffs[[k]])
    df[[paste0("Δ", k - 1)]] <- col
  }
  return(list(diffs = diffs, table = df))
}

# Tabla de diferencias hacia atrás
backward_diff_table <- function(x, y) {
  n <- length(y)
  diffs <- list(y)
  for (k in 1:(n - 1)) {
    diffs[[k + 1]] <- diff(diffs[[k]])
  }
  df <- data.frame(x = x)
  for (k in 1:length(diffs)) {
    col <- c(diffs[[k]], rep(NA, k - 1))
    df[[paste0("∇", k - 1)]] <- col
  }
  return(list(diffs = diffs, table = df))
}

# Factorial
fact <- function(n) if (n <= 1) 1 else prod(1:n)

# Interpolación Newton equiespaciada automática
newton_interp_equispaced <- function(x_nodes, y_nodes, x_eval) {
  h <- x_nodes[2] - x_nodes[1]
  n <- length(x_nodes)
  
  # Decidir si usar hacia adelante o hacia atrás
  if (x_eval <= mean(x_nodes)) {
    method <- "adelante"
    diffs <- forward_diff_table(x_nodes, y_nodes)$diffs
    a <- sapply(diffs, function(v) v[1])
    s <- (x_eval - x_nodes[1]) / h
    p <- a[1]
    for (k in 2:length(a)) {
      term <- a[k]
      num <- 1
      for (j in 0:(k - 2)) num <- num * (s - j)
      p <- p + term * num / fact(k - 1)
    }
    # error de truncamiento (estimado con último término)
    error <- abs(a[length(a)] * s * prod(s - (0:(length(a) - 2))) / fact(length(a) - 1))
  } else {
    method <- "atrás"
    diffs <- backward_diff_table(x_nodes, y_nodes)$diffs
    a <- sapply(diffs, function(v) v[length(v)])
    s <- (x_eval - x_nodes[n]) / h
    p <- a[1]
    for (k in 2:length(a)) {
      term <- a[k]
      num <- 1
      for (j in 0:(k - 2)) num <- num * (s + j)
      p <- p + term * num / fact(k - 1)
    }
    error <- abs(a[length(a)] * s * prod(s + (0:(length(a) - 2))) / fact(length(a) - 1))
  }
  
  return(list(valor = p, metodo = method, error = error))
}

# Interpolación de Lagrange clásica
lagrange_interp <- function(x, y, x_eval) {
  n <- length(x)
  P <- 0
  for (i in 1:n) {
    L <- 1
    for (j in 1:n) {
      if (j != i) L <- L * (x_eval - x[j]) / (x[i] - x[j])
    }
    P <- P + y[i] * L
  }
  return(P)
}

# Interpolación de Newton (diferencias divididas)
newton_divididas <- function(x, y, x_eval) {
  n <- length(x)
  # Tabla de diferencias divididas
  dd <- matrix(0, n, n)
  dd[,1] <- y
  for (j in 2:n) {
    for (i in 1:(n - j + 1)) {
      dd[i, j] <- (dd[i + 1, j - 1] - dd[i, j - 1]) / (x[i + j - 1] - x[i])
    }
  }
  # Evaluación
  P <- dd[1, 1]
  for (j in 2:n) {
    term <- dd[1, j]
    for (k in 1:(j - 1)) term <- term * (x_eval - x[k])
    P <- P + term
  }
  return(list(valor = P, tabla = dd))
}
```

##  Replicar ejemplos anteriores

```{r}
# Datos del ejercicio anterior (x = 0:4, f = 1,2,4,8,16)
x1 <- 0:4
y1 <- c(1, 2, 4, 8, 16)

# Tabla de diferencias
tabla1 <- forward_diff_table(x1, y1)
print("Tabla de diferencias progresivas:")
print(tabla1$table)

# Valor estimado f(2.5)
res1 <- newton_interp_equispaced(x1, y1, 2.5)
print(paste("Valor estimado f(2.5) =", round(res1$valor, 4)))
print(paste("Método usado:", res1$metodo))
print(paste("Error de truncamiento estimado:", round(res1$error, 6)))

# Comparación con valor real 2^2.5
real_25 <- 2^(2.5)
print(paste("Valor real =", round(real_25, 4)))
print(paste("Error total =", round(abs(res1$valor - real_25), 6)))

# Gráfica
# Gráfica sin error (corregida)
plot(x1, y1, pch = 19, col = "blue", main = "Interpolación Newton hacia adelante",
     xlab = "x", ylab = "f(x)")

# Función auxiliar para evaluar la interpolación punto a punto
interp_fun <- function(xx) newton_interp_equispaced(x1, y1, xx)$valor

# Secuencia de puntos para trazar la curva
x_seq <- seq(min(x1), max(x1), 0.1)
y_seq <- sapply(x_seq, interp_fun)

# Dibujar el polinomio interpolante
lines(x_seq, y_seq, col = "red", lwd = 2)

legend("topleft", legend = c("Datos originales", "Polinomio interpolante"),
       col = c("blue", "red"), pch = c(19, NA), lty = c(NA, 1))

```


## Comparación de métodos (Lagrange, Newton, Diferencias finitas)

```{r}
set.seed(123)
x2 <- sort(runif(5, 0, 10))
y2 <- 3 + 2 * x2 + 0.5 * x2^2  # función cuadrática
x_plot <- seq(min(x2), max(x2), 0.1)

# Lagrange
y_lag <- sapply(x_plot, function(x) lagrange_interp(x2, y2, x))

# Newton divididas
y_new <- sapply(x_plot, function(x) newton_divididas(x2, y2, x)$valor)

# Newton hacia adelante (equiespaciado usando x equidistantes)
x_eq <- seq(min(x2), max(x2), length.out = 5)
y_eq <- 3 + 2 * x_eq + 0.5 * x_eq^2
y_forw <- sapply(x_plot, function(x) newton_interp_equispaced(x_eq, y_eq, x)$valor)

# Gráfica comparativa
plot(x2, y2, pch = 19, col = "black", xlab = "x", ylab = "f(x)",
     main = "Comparación de métodos de interpolación")
lines(x_plot, y_lag, col = "red", lwd = 2)
lines(x_plot, y_new, col = "blue", lwd = 2, lty = 2)
lines(x_plot, y_forw, col = "green", lwd = 2, lty = 3)
legend("topleft", legend = c("Datos", "Lagrange", "Newton divididas", "Newton hacia adelante"),
       col = c("black", "red", "blue", "green"), lty = c(NA, 1, 2, 3), pch = c(19, NA, NA, NA))
```


## Evaluar con datos dados

x = [0,1,2,3,4],  
y = [2.0, 2.7, 4.8, 8.9, 16.0]

```{r}
# Ejercicio 7 - Punto 3
x3 <- c(0, 1, 2, 3, 4)
y3 <- c(2.0, 2.7, 4.8, 8.9, 16.0)

# Evaluaciones automáticas
x_eval <- c(1.5, 2.5, 3.5)
resultados <- lapply(x_eval, function(xx) newton_interp_equispaced(x3, y3, xx))
valores_est <- sapply(resultados, function(r) r$valor)

# Reporte de resultados
print(data.frame(x_eval, f_estimado = valores_est))

# Comparación con función de referencia f(x) = 2^x
f_ref <- 2^x_eval
print(data.frame(x_eval, f_estimado = valores_est, f_real = f_ref,
                 error = f_ref - valores_est))

# Gráfica (corregida)
plot(x3, y3, pch = 19, col = "blue", main = "Interpolación automática Newton",
     xlab = "x", ylab = "f(x)")

# Evaluar punto a punto (evita error)
interp_fun <- function(xx) newton_interp_equispaced(x3, y3, xx)$valor
x_seq <- seq(min(x3), max(x3), 0.1)
y_seq <- sapply(x_seq, interp_fun)

lines(x_seq, y_seq, col = "red", lwd = 2)
points(x_eval, valores_est, col = "darkgreen", pch = 17)

legend("topleft",
       legend = c("Datos originales", "Interpolante", "Puntos evaluados"),
       col = c("blue", "red", "darkgreen"), pch = c(19, NA, 17), lty = c(NA, 1, NA))

```

